#!/usr/bin/env bash

# +-------------+--------------------------------------------------------------
# | filename	| .bash-ck (symlink by: ln -s .bash-ck .bash_profile)
# | version		| tracked at https://github.com/mickeys/dotfiles
# | purpose		| single bash run-commands file for CK local & vagrant hosts
# +-------------+--------------------------------------------------------------

#set -x										# toggle debugging verbosity
# github.com/koalaman/shellcheck is used to bomb-proof this (and other) scripts
# shellcheck disable=1090,1091				# tell shellcheck source script URLs
set -u o pipefail							# unofficial bash strict mode

# =============================================================================
# Aliases, alphabetically
# =============================================================================
export BLOCKSIZE=1k							# default blocksize for ls, df, du
alias c='clear'								# clear terminal screen
alias d="printf \"\033[31;1;31m%0.s*\033[0m\" {1..111}" # easy-to-see red line
alias df='df -h'							# show human-readable sizes
alias h='history'							# bash command history
alias pd='pushd'							# manipulate directory stack

# =============================================================================
# Enhance terminal commands with color (if capable).
# =============================================================================
if tput colors ne "-1" &> /dev/null ; then
	export CLICOLOR=1						# make ls colorful
	export LSCOLORS='BxGxfxfxCxdxdxhbadbxbx'
	export TERM=xterm-color					# use color-capable termcap
fi

# =============================================================================
# Determine whether you're on a local or remote (vagrant) instance.
# =============================================================================
if [[ $HOSTNAME == ip-* ]] ; then			# vagrant hosts = 'ip-12-34-56-78'

	#.,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``#
	#																		  #
	#		Vagrant (remote) host environment configuration section.		  #
	#																		  #
	#``°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸#

	# -------------------------------------------------------------------------
	# Show elapsed time of last shell command as part of the prompt string.
	# -------------------------------------------------------------------------
	function timer_start {
		timer=${timer:-$SECONDS}
	}

	function timer_stop {
		export timer_show=$((SECONDS - timer))
		unset timer
	}

	trap 'timer_start' DEBUG

	if [ -n "${PROMPT_COMMAND:-}" ]; then
		PROMPT_COMMAND="$PROMPT_COMMAND; timer_stop"
	else
		PROMPT_COMMAND="timer_stop"
	fi

	# -------------------------------------------------------------------------
	# Set the terminal prompt.
	# -------------------------------------------------------------------------
	__h=${HOSTNAME#*-}						# preserve everything after first '-'
	__g=${__h//-/.}							# substitute '-' with '.'

	# shellcheck disable=SC2016				# we really need the variable name
	_TIMER='${timer_show}s'					# single-quotes important here!
	_ELAPS="\[\033[38;5;248m\]$_TIMER$(tput bold)\]"
	_HOST="\[\033[38;5;1m\]${__g}\[$(tput sgr0)\]"
	_DIR="\[\033[38;5;248m\]\W\[$(tput sgr0)\]"
	_BRANCH="\[\033[01;31m\]$(git branch 2>/dev/null | cut -f2 -d\* -s)\[\033[01;32m\]"
	_PROMPT="\[\033[38;5;2m\]\\$\[$(tput sgr0)\]"

	export PS1="$_ELAPS $_HOST $_DIR $_PROMPT "

else

	#.,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``#
	#																		  #
	#		Local (laptop) host environment configuration section.			  #
	#																		  #
	#``°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸#

	# -------------------------------------------------------------------------
	# git version control system (git-scm.com)
	#
	# see also: http://nuclearsquid.com/writings/git-tricks-tips-workflows/
	# and also: http://durdn.com/blog/2012/11/22/must-have-git-aliases-advanced-examples/
	# -------------------------------------------------------------------------
	complete -o default -o nospace -F _git g # autocomplete for 'g' as well
	ga() { git add "$1"\ ; }				# add files to be tracked
	gc() { git commit -m "$@" ; }			# commit changes locally
	keysx() { tr '[:upper:]' '[:lower:]' < "$1" | sort | uniq | wc -l ; }

	alias g='git'							# save 66% of typing
	alias gb='git branch'					# so many parallel universes :-)
	alias gd='git diff'						# see what happened
	alias gh='git log --follow '			# git history for a file
	alias gi='git check-ignore -v *'		# see what's being ignored
#	alias gl='git log --pretty=format:" ~ %s (%cr)" --no-merges'
	alias gl='git log --no-merges --date=short --pretty=format:"| %cd | %s [%an]"'
	alias go='git remote show origin'
	alias gp='git push -u origin master'	# send changes upstream
	alias gs='git status'					# summarize; you may like --short
	alias gsl='git stash list'				# git-stash(1)
	alias gsp='git stash pop'				# git-stash(1)
	alias gss='git stash save'				# git-stash(1)

	# -------------------------------------------------------------------------
	# Homebrew macOS package manager (brew.sh)
	# -------------------------------------------------------------------------
	if command -v brew > /dev/null ; then	# if homebrew is installed
		alias brewski='brew update && brew upgrade && brew cleanup; brew doctor'
		alias brew_installed='brew leaves'	# top-level installed packages
		alias brew_versions='brew list --versions'
		_BREW=1								# remember: homebrew is installed
	else
		unset _BREW							# remember: homebrew not installed
	fi

	# -------------------------------------------------------------------------
	# GNU core utilities (coreutils) (via homebrew)
	# -------------------------------------------------------------------------
	if command -v gls > /dev/null ; then
		alias ll='gls -lAhF'				# ls with kb, mb, gb
		alias lr='gls -R | grep ":$" | sed -e '\''s/:$//'\'' -e '\''s/[^-][^\/]*\//--/g'\'' -e '\''s/^/   /'\'' -e '\''s/-/|/'\'' | $PAGER' # lr ~ fully-recursive directory listing
		alias ls='gls -FG --time-style=iso --color=auto'
	fi

	# -------------------------------------------------------------------------
	# MySQL (via homebrew)
	# -------------------------------------------------------------------------
	export _MYSQL='/usr/local/opt/mysql@5.6/'
	if [ -e "$_MYSQL" ] ; then
		export PATH="${_MYSQL}/bin:$PATH"	# find executables
		export LDFLAGS="-L${_MYSQL}/lib"	# for compilers
		export CPPFLAGS="-I${_MYSQL}/include"

		alias mysql='mysql -uroot'	# connect
		alias mysql_start='${_MYSQL}/bin/mysql.server start' # start manually
		# brew services start mysql@5.6		# start automatically
	fi

	# -------------------------------------------------------------------------
	# OpenSSL (via homebrew)
	#
	# A CA file has been bootstrapped using certificates from the SystemRoots
	# keychain. To add additional certificates (e.g. the certificates added in
	# the System keychain), place .pem files in /usr/local/etc/openssl/certs and
	# run openssl_rehash.
	# -------------------------------------------------------------------------
	export _OPENSSL="/usr/local/opt/openssl"
	if [ -e "$_OPENSSL" ] ; then
		export PATH="${_OPENSSL}/bin:$PATH"	# find executables
		export LDFLAGS="-L${_OPENSSL}/lib"	# for compilers
		export CPPFLAGS="-I${_OPENSSL}/include"

		alias openssl_rehash='${_OPENSSL}/bin/c_rehash'
	fi

	# -------------------------------------------------------------------------
	# gpg2 (via homebrew) used by rvm (Ruby version manager)
	# -------------------------------------------------------------------------
	if command -v gpg2 > /dev/null ; then	# if package is installed
		export LDFLAGS="-L/usr/local/opt/libffi/lib"	# for compilers
		export PKG_CONFIG_PATH="/usr/local/opt/libffi/lib/pkgconfig" # for pkg-config
	fi

	# =========================================================================
	# Bash-completion (via homebrew) presents options to the user when the Tab
	# key is pressed. Read github.com/bobthecow/git-flow-completion
	# =========================================================================
	if [[ -n ${_BREW-} ]] && brew ls --versions bash-completion > /dev/null; then
		# The package is installed.
		# shellcheck source=/usr/local/opt/git/etc/bash_completion.d/git-completion.bash
		source "$( brew --prefix git )"/etc/bash_completion.d/git-completion.bash
		source "$( brew --prefix git )"/etc/bash_completion.d/git-prompt.sh
	fi

	# -------------------------------------------------------------------------
	# Set the terminal prompt.
	# -------------------------------------------------------------------------
	# shellcheck disable=SC2155				# ignore well-established convention
	_DIR="\[\033[38;5;248m\]\W\[$(tput sgr0)\]"
	_BRANCH="\[\033[01;31m\]$(git branch 2>/dev/null | cut -f2 -d\* -s)\[\033[01;32m\]"
	_PROMPT="\[\033[38;5;2m\]\\$\[$(tput sgr0)\]"

	export PS1="$_DIR$_BRANCH $_PROMPT "

	# -------------------------------------------------------------------------
	# Solutions to developing locally (on a laptop) while testing on a remote
	# (vagrant) instance. First pass of this covers working with one remote; if
	# multiple remotes become common we'll tackle that situation next.
	#
	# 1 Spin up your remote (vagrant UAT).
	# 2 Place the remote IP address into _REMO, below.
	# 3 Generate proper commands with `source ~/.bash_profile`.
	# 4 `cpk` for password-less secure shell (ssh, scp).
	# 5 `cpb` to make the remote login shell behave as you've specified above.
	# 6 `sshr` to connect; enjoy!
	# -------------------------------------------------------------------------
	cpbash() {
		if [ -z "$1" ] ; then				# explain proper usage if no host
			echo "usage: ${FUNCNAME[0]} UserName@RemoteHost:"
		else
			echo scp -L -i "$_SSHK" "$HOME/.bash-profile" "$1" # copy this to remote
		fi
	}

	export _REMO='172.30.30.215'			# your remote's IP addr
	export _SSHK="$HOME/.ssh/github-ck"		# your local private SSH key
	alias cpb="cpbash vagrant@\${_REMO}:"	# copy this bash file to remote
	alias cpk="ssh-copy-id -i \${_SSHK} vagrant@\${_REMO}" # copy key; no passwd
	alias sshr="ssh vagrant@\${_REMO}"		# -i ${_SSHK} unneeded

	# -------------------------------------------------------------------------
	# Copy local work to the remote in one fell swoop! Git commit at success!
	# -------------------------------------------------------------------------
	export _LOCAL_CHEDDAR="$HOME/git-repos/automation/cheddar"
	export _REMO_CHEDDAR="/var/www/git-repos/automation/cheddar"

	alias cheddar="cd \$_LOCAL_CHEDDAR"		# mimic vagrant command

	alias rch="rsync --dry-run --human-readable --progress \
		-e \"ssh -i \$_SSHK\" \
		-avz \$_LOCAL_CHEDDAR/ vagrant@\$_REMO:\$_REMO_CHEDDAR/"

	# -------------------------------------------------------------------------
	# Copy local work to/from the remote one file or folder at a time.
	# -------------------------------------------------------------------------
	touat () {
		if [ -z "$1" ]; then
			echo "usage: ${FUNCNAME[0]} UAT_LAST_IP LocalFileName RemoteFilePath"
		else
			scp -i "$_SSHK" "$2" "vagrant@172.30.8.$1:$3"
		fi
	}

	fromuat () {
		if [ -z "$1" ]; then
			echo "usage: ${FUNCNAME[0]} UAT_LAST_IP RemoteFilePath LocalFileName"
		else
			scp -i "$_SSHK" "vagrant@172.30.8.$1:$2" "$3"
		fi
	}

	# -------------------------------------------------------------------------
	# Miscellany.
	# -------------------------------------------------------------------------
	tit() { echo -ne "\033]0;${*}\007" ; }	# iTerm -- set tab name
	alias hosts='cat /etc/hosts'			# to what exactly are you pointing?

	# -------------------------------------------------------------------------
	# Cisco Umbrella roaming client - resetting to route around occasional issue
	# -------------------------------------------------------------------------
	ustart () {
		sudo launchctl load /Library/LaunchDaemons/com.opendns.osx.RoamingClientConfigUpdater.plist
		launchctl load /Library/LaunchAgents/com.opendns.osx.RoamingClientMenubar.plist
	}

	ustop () {
		sudo launchctl remove com.opendns.osx.RoamingClientConfigUpdater
		launchctl remove com.opendns.osx.RoamingClientMenubar
		sudo killall OpenDNSDiagnostic &>/dev/null
	}

	# -------------------------------------------------------------------------
	# Remove duplicate $PATH entries.
	# -------------------------------------------------------------------------
	cleanPath() {
		if [ -n "$PATH" ]; then				# if the system PATH exists
		  oldPath=$PATH:; newPath=			# make a copy & new working space
		  while [ -n "$oldPath" ]; do		# while there's still something left
			x=${oldPath%%:*}				# get the first remaining entry
			case $newPath: in
			  *:"$x":*) ;;					# already there, do nothing
			  *) newPath=$newPath:$x;;    	# not there yet; add
			esac
			oldPath=${oldPath#*:}
		  done
		  PATH=${newPath#:}					# set system PATH to uniq'd version
		  unset oldPath newPath x			# clean up after ourselves
		fi
	}

	cleanPath								# remove duplicates from PATH
	export PATH								# share and enjoy!
fi
