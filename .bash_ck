#!/usr/bin/env bash

# +------------------------+---------------------------------------------------
# .                        . This is a basic .bash_profile for Credit Karma. It
# .            `:-         . covers configuration for both local (laptop) and
# .            ./:         . remote hosts (CKVM & UAT).
# .     `...`  ./:     --` .
# .  `://:-::: ./:   `:/:  . Clone this file, test it by `source .bash_ck`, and
# . `//-       ./:  .//-   . when you're sure it's right for you, symlink it to
# . .//        ./:.://`    . your home by `ln -s .bash_ck .bash_profile`.
# . `//.       .///::/:`   .
# .  -//:...-: .//`  -//`  . 
# .    .-::--. `--    .--` . Find me at https://github.com/mickeys/dotfiles/ or
# .                        . code.corp.creditkarma.com/michael-sattler-ck/dotfiles/
# +------------------------+---------------------------------------------------

#set -x										# toggle debugging verbosity
# github.com/koalaman/shellcheck is used to bomb-proof this (and other) scripts
# shellcheck disable=1090,1091				# tell shellcheck source script URLs
#set -u o pipefail							# unofficial bash strict mode

# =============================================================================
# =============================================================================
_MY_SECRETS="$HOME/.my_ck_secrets"
if [ -e "$_MY_SECRETS" ] ; then
	# shellcheck source=/Users/michael.sattler/.my_ck_secrets
	source "$_MY_SECRETS"
else
	echo "Configuration file \"$_MY_SECRETS\" not found."
fi

# =============================================================================
# Aliases, alphabetically
# =============================================================================
export BLOCKSIZE=1k							# default blocksize for ls, df, du

alias c='clear'								# clear terminal screen
alias df='df -h'							# show human-readable sizes
alias h='history'							# bash command history
alias l='ls -l -A'							# long listing, hiddens
alias ll='ls -lAhF'							# kb, mb, gb; hiddens; classified
alias lr='ls -R | grep ":$" | sed -e '\''s/:$//'\'' -e '\''s/[^-][^\/]*\//--/g'\'' -e '\''s/^/   /'\'' -e '\''s/-/|/'\'' | $PAGER' # lr ~ fully-recursive directory listing
alias pd='pushd'							# manipulate directory stack

# =============================================================================
# Enhance terminal commands with color (if capable).
# =============================================================================
if tput colors ne "-1" &> /dev/null ; then
	export CLICOLOR=1						# make ls colorful
	export LSCOLORS='BxGxfxfxCxdxdxhbadbxbx'
	export TERM=xterm-color					# use color-capable termcap
fi

# =============================================================================
# Miscellaneous common things.
# =============================================================================
if command -v less &> /dev/null ; then export PAGER='less' ; else export PAGER='more' ; fi

# =============================================================================
# Determine whether you're on a local or remote (vagrant) instance.
# =============================================================================
if [[ $HOSTNAME == ip-* ]] ; then			# vagrant hosts = 'ip-12-34-56-78'

	#.,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``#
	#																		  #
	#		Vagrant (remote) host environment configuration section.		  #
	#																		  #
	#``°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸#

	# -------------------------------------------------------------------------
	# Show elapsed time of last shell command as part of the prompt string.
	# -------------------------------------------------------------------------
	function timer_start {
		timer=${timer:-$SECONDS}
	}

	function timer_stop {
		export timer_show=$((SECONDS - timer))
		unset timer
	}

	trap 'timer_start' DEBUG

	if [ -n "${PROMPT_COMMAND:-}" ]; then
		PROMPT_COMMAND="$PROMPT_COMMAND; timer_stop"
	else
		PROMPT_COMMAND="timer_stop"
	fi

	# -------------------------------------------------------------------------
	# Set the terminal prompt.
	# -------------------------------------------------------------------------
	__h=${HOSTNAME#*-}						# preserve everything after first '-'
	__g=${__h//-/.}							# substitute '-' with '.'

	# shellcheck disable=SC2016				# we really need the variable name
	_TIMER='${timer_show}s'					# single-quotes important here!
	_ELAPS="\[\033[38;5;248m\]$_TIMER$(tput bold)\]"
	_HOST="\[\033[38;5;1m\]${__g}\[$(tput sgr0)\]"
	_DIR="\[\033[38;5;248m\]\W\[$(tput sgr0)\]"
	_BRANCH="\[\033[01;31m\]$(git branch 2>/dev/null | cut -f2 -d\* -s)\[\033[01;32m\]"
	_PROMPT="\[\033[38;5;2m\]\\$\[$(tput sgr0)\]"

	export PS1="$_ELAPS $_HOST $_DIR $_PROMPT "

else

	#.,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``°º¤ø.¸,ø¤º°``#
	#																		  #
	#		Local (laptop) host environment configuration section.			  #
	#																		  #
	#``°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø,¸#

	# -------------------------------------------------------------------------
	# git version control system (git-scm.com)
	#
	# see also: http://nuclearsquid.com/writings/git-tricks-tips-workflows/
	# and also: http://durdn.com/blog/2012/11/22/must-have-git-aliases-advanced-examples/
	# -------------------------------------------------------------------------
	complete -o default -o nospace -F _git g # autocomplete for 'g' as well
	ga() { git add "$1"\ ; }				# add files to be tracked
	gc() { git commit -m "$@" ; }			# commit changes locally
	keysx() { tr '[:upper:]' '[:lower:]' < "$1" | sort | uniq | wc -l ; }

	alias g='git'							# save 66% of typing
	alias gb='git branch'					# so many parallel universes :-)
	alias gd='git diff'						# see what happened
	alias gh='git log --follow '			# git history for a file
	alias gi='git check-ignore -v *'		# see what's being ignored
#	alias gl='git log --pretty=format:" ~ %s (%cr)" --no-merges'
	alias gl='git log --no-merges --date=short --pretty=format:"| %cd | %s [%an]"'
	alias go='git remote show origin'
	alias gp='git push -u origin master'	# send changes upstream
	alias gs='git status'					# summarize; you may like --short
	alias gsl='git stash list'				# git-stash(1)
	alias gsp='git stash pop'				# git-stash(1)
	alias gss='git stash save'				# git-stash(1)

	# -------------------------------------------------------------------------
	# Homebrew macOS package manager (brew.sh)
	# -------------------------------------------------------------------------
	if command -v brew > /dev/null ; then	# if homebrew is installed
		alias brewski='brew update && brew upgrade && brew cleanup; brew doctor'
		alias brew_installed='brew leaves'	# top-level installed packages
		alias brew_versions='brew list --versions'
		_BREW=1								# remember: homebrew is installed
	else
		unset _BREW							# remember: homebrew not installed
	fi

	# -------------------------------------------------------------------------
	# GNU core utilities (coreutils) (via homebrew)
	# -------------------------------------------------------------------------
	if command -v gdircolors > /dev/null ; then
		export COLUMNS						# remember columns for subprocesses
		eval "$(gdircolors)"				# activate default color database
#		function ls {
#			command ls -F -h --color=auto -v --author --time-style=long-iso -C "$@" | $PAGER -R -X -F
#		}
	fi

	# -------------------------------------------------------------------------
	# MySQL (via homebrew)
	# -------------------------------------------------------------------------
	export _MYSQL='/usr/local/opt/mysql@5.6/'
	if [ -e "$_MYSQL" ] ; then
		export PATH="${_MYSQL}/bin:$PATH"	# find executables
		export LDFLAGS="-L${_MYSQL}/lib"	# for compilers
		export CPPFLAGS="-I${_MYSQL}/include"

		alias mysql='mysql -uroot'	# connect
		alias mysql_start='${_MYSQL}/bin/mysql.server start' # start manually
		# brew services start mysql@5.6		# start automatically
	else
		unset _MYSQL						# not installed? not needed!
	fi

	# -------------------------------------------------------------------------
	# OpenSSL (via homebrew)
	#
	# A CA file has been bootstrapped using certificates from the SystemRoots
	# keychain. To add additional certificates (e.g. the certificates added in
	# the System keychain), place .pem files in /usr/local/etc/openssl/certs and
	# run openssl_rehash.
	# -------------------------------------------------------------------------
	export _OPENSSL="/usr/local/opt/openssl"
	if [ -e "$_OPENSSL" ] ; then
		export PATH="${_OPENSSL}/bin:$PATH"	# find executables
		export LDFLAGS="-L${_OPENSSL}/lib"	# for compilers
		export CPPFLAGS="-I${_OPENSSL}/include"

		alias openssl_rehash='${_OPENSSL}/bin/c_rehash'
	else
		unset _OPENSSL						# not installed? not needed!
	fi

	# -------------------------------------------------------------------------
	# gpg2 (via homebrew) used by rvm
	# -------------------------------------------------------------------------
	if command -v gpg2 > /dev/null ; then	# if package is installed
		export LDFLAGS="-L/usr/local/opt/libffi/lib"	# for compilers
		export PKG_CONFIG_PATH="/usr/local/opt/libffi/lib/pkgconfig" # for pkg-config
	fi

	# =========================================================================
	# Bash-completion (via homebrew) presents options to the user when the Tab
	# key is pressed. Read github.com/bobthecow/git-flow-completion
	# =========================================================================
	if [[ -n ${_BREW-} ]] && brew ls --versions bash-completion > /dev/null; then
		# shellcheck source=/usr/local/opt/git/etc/bash_completion.d/git-completion.bash
		source "$( brew --prefix git )"/etc/bash_completion.d/git-completion.bash
		# shellcheck source=/usr/local/opt/git/etc/bash_completion.d/git-prompt.sh
		source "$( brew --prefix git )"/etc/bash_completion.d/git-prompt.sh
	fi

	# -------------------------------------------------------------------------
	# Set the terminal prompt.
	# -------------------------------------------------------------------------
	# shellcheck disable=SC2155				# ignore well-established convention
	_DIR="\[\033[38;5;248m\]\W\[$(tput sgr0)\]"
	_BRANCH="\[\033[01;31m\]$(git branch 2>/dev/null | cut -f2 -d\* -s)\[\033[01;32m\]"
	_PROMPT="\[\033[38;5;2m\]\\$\[$(tput sgr0)\]"

	export PS1="$_DIR$_BRANCH $_PROMPT "

	# -------------------------------------------------------------------------
	# Solutions to developing locally (on a laptop) while testing on a remote
	# (vagrant) instance. First pass of this covers working with one remote; if
	# multiple remotes become common we'll tackle that situation next.
	#
	# 1 Spin up your remote (vagrant UAT).
	# 2 Place the remote IP address into _REMO, below.
	# 3 Generate proper commands with `source ~/.bash_profile`.
	# 4 `cpk` for password-less secure shell (ssh, scp).
	# 5 `cpb` to make the remote login shell behave as you've specified above.
	# 6 `sshr` to connect; enjoy!
	# -------------------------------------------------------------------------
	cpbash() {
		if [ -z "$1" ] ; then				# explain proper usage if no host
			echo "usage: ${FUNCNAME[0]} UserName@RemoteHost:"
		else
			echo scp -L -i "$_SSHK" "$HOME/.bash-profile" "$1" # copy this to remote
		fi
	}

	# -------------------------------------------------------------------------
	# Print a red line to make it easy to scroll back to this point in terminal.
	# -------------------------------------------------------------------------
	function d {
		printf "\033[31;1;31m%0.s*\033[0m" {1..111} # easy-to-see red line
		printf "\n"							# trailing blank line
	}

	# -------------------------------------------------------------------------
	# Keep just one ssh-agent running in a multi-tab environment, per
	# http://rabexc.org/posts/pitfalls-of-ssh-agents
	#
	# ssh-add(1) says exit status is 0 on success, 1 if the specified command
	# fails, and 2 if ssh-add is unable to contact the authentication agent.
	# -------------------------------------------------------------------------
	ssh-add -l &>/dev/null					# ssh-add list all known keys
	if [ "$?" == 2 ]; then					# if unable to contact ssh-agent
		test -r ~/.ssh-agent && \
			eval "$(<~/.ssh-agent)" >/dev/null # if file readable read environ

		ssh-add -l &>/dev/null				# ssh-add list all known keys
		if [ "$?" == 2 ]; then				# if unable to contact ssh-agent
			(umask 066; ssh-agent > ~/.ssh-agent) # start w 066 & save output
			eval "$(<~/.ssh-agent)" >/dev/null	# if file readable read environ
			ssh-add							# add keys
		fi
	fi

	# -------------------------------------------------------------------------
	# Which SSH private key to be used for authenticating to remotes?
	# -------------------------------------------------------------------------
	if [ -f "$HOME/.ssh/github-ck" ] ; then
		export _SSHK="$HOME/.ssh/github-ck"	# CK-specific private SSH key
	else
		export _SSHK="$HOME/.ssh/id_rsa"	# default private SSH key
	fi

	alias cpb="cpbash vagrant@\${_REMO}:"	# copy this bash file to remote
	alias cpk="ssh-copy-id -i \${_SSHK} vagrant@\${_REMO}" # copy key; no passwd
	alias sshr="ssh vagrant@\${_REMO}"		# -i ${_SSHK} unneeded

	# -------------------------------------------------------------------------
	# Set up and sanity-check local and remote cheddar git trees.
	# -------------------------------------------------------------------------
	export _REMO_CHEDDAR="/var/www/git-repos/automation/cheddar"
	export _LOCAL_CHEDDAR="$HOME/git-repos/automation/cheddar"

	if [ ! -d "$_LOCAL_CHEDDAR" ] ; then
		echo "warning: not finding local cheddar at \"${_LOCAL_CHEDDAR/$HOME/\~}\""
	else
		alias cheddar="cd \$_LOCAL_CHEDDAR"	# mimic vagrant command
	fi

	# if ( remote-checking-wanted and network-is-present ) check remote
	_NETWORK_UP=$(eval nc -dzw1 8.8.8.8 443 &> /dev/null)
	if [[ ${_CHECK_REMOTE_CHEDDAR:-} && $_NETWORK_UP ]] ; then
		if ! ssh -i "$_SSHK" vagrant@"${_REMO}" test -d "$_REMO_CHEDDAR" ; then
			echo "warning: not finding remote cheddar at \"$_REMO:$_REMO_CHEDDAR/\""
		fi
	else
		echo 'info: not checking remote cheddar file structure.'
	fi

	# -------------------------------------------------------------------------
	# Copy local work to the remote in one fell swoop! Git commit at success!
	# -------------------------------------------------------------------------
	alias rch="rsync --dry-run --human-readable --progress \
		-e \"ssh -i \$_SSHK\" \
		-avz \$_LOCAL_CHEDDAR/ vagrant@\$_REMO:\$_REMO_CHEDDAR/"

	# -------------------------------------------------------------------------
	# SauceLabs
	# -------------------------------------------------------------------------
	if [[ ${_SAUCE_LABS_ACCESS_KEY:-} ]] ; then

		_SL_L_PRETTY="${_SAUCE_DIR/$HOME/\~}"	# easier-to-read output below
		# shellcheck disable=SC2086				# must glob to expand matches
		set -- $_SAUCE_DIR						# glob expand all matching dirs
		if [[ $# -eq 0 ]] ; then
			echo "warning: missing SauceLabs folder at \"$_SL_L_PRETTY\"."
		elif [[ $# -gt 1 ]] ; then
			echo "warning: too many SauceLabs folders at \"$_SL_L_PRETTY\"."
		fi

		# shellcheck disable=2139				# expand when aliased 
		alias sauce="ulimit -n 8000 && $_SAUCE_DIR/bin/sc \
			-u \"$_SAUCE_USERNAME\" \
			-k \"$_SAUCE_LABS_ACCESS_KEY\" \
			-i \"$_SAUCE_TUNNELNAME\""
	fi

	# -------------------------------------------------------------------------
	# iTerm2 -- www.iterm2.com 
	#
	# this is an expanded, corrected version of:
	# https://superuser.com/questions/419775/with-bash-iterm2-how-to-name-tabs
	# -------------------------------------------------------------------------
	# if iTerm2 shell integration exists then use it
	test -e "${HOME}/.iterm2_shell_integration.bash" && \
		source "${HOME}/.iterm2_shell_integration.bash"

	# -------------------------------------------------------------------------
	# set iTerm2 tab titles automagically (and manually)
	# -------------------------------------------------------------------------
	# shellcheck disable=SC2120				# it's ok to call title() w/o args
	title() {
		if [ "$ITERM_SESSION_ID" ]; then	# only relavent if within iTerm?
			if [ "$1" ] ; then				# if the user supplied a tab title
				# shellcheck disable=SC2015
				test -e "${HOME}/.iterm2_shell_integration.bash" \
					&& export PROMPT_COMMAND='__bp_precmd_invoke_cmd' \
					|| unset PROMPT_COMMAND
				echo -ne "\033]0;${*}\007"
			else							# if there's no tab title use PWD
				# shellcheck disable=SC2015
				test -e "${HOME}/.iterm2_shell_integration.bash" \
					&& export PROMPT_COMMAND='echo -ne "\033]0;${PWD/#$HOME/\~}\007";__bp_precmd_invoke_cmd' \
					|| export PROMPT_COMMAND='echo -ne "\033]0;${PWD/#$HOME/\~}\007"'
			fi								# end of use PWD
		fi									# end of ITERM_SESSION_ID
	}										# end of title()
	# shellcheck disable=SC2119				# it's ok to call title() w/o args
	title									# set iTerm tab if within iTerm

	# -------------------------------------------------------------------------
	# Miscellany
	# -------------------------------------------------------------------------
	alias bb='bbedit'						# use BBEdit text editor from shell
	alias hosts='cat /etc/hosts'			# to what exactly are you pointing?
	alias sc='shellcheck'					# syntax-check shell scripts
	alias showpath="echo \"${PATH//:/$'\n'}\" | sort" # PATH, line by line
	alias sshkey='ssh-keygen -l -E MD5 -f'	# fingerprint ssh key to verify

	if command -v vagrant &> /dev/null ; then
		alias vhalt='vagrant halt'
		alias vreload='vagrant reload'
		alias vssh='vagrant ssh'
		alias vstat='vagrant status'
		alias vup='vagrant up'
	fi

	# shellcheck disable=SC2155				# declare and assign separately...
	export JAVA_HOME=$(/usr/libexec/java_home) # dynamically get proper value

	# -------------------------------------------------------------------------
	# Cisco Umbrella roaming client - resetting to route around occasional issue
	# -------------------------------------------------------------------------
	ustart () {
		sudo launchctl load /Library/LaunchDaemons/com.opendns.osx.RoamingClientConfigUpdater.plist
		launchctl load /Library/LaunchAgents/com.opendns.osx.RoamingClientMenubar.plist
	}

	ustop () {
		sudo launchctl remove com.opendns.osx.RoamingClientConfigUpdater
		launchctl remove com.opendns.osx.RoamingClientMenubar
		sudo killall OpenDNSDiagnostic &>/dev/null
	}

	# -------------------------------------------------------------------------
	# Remove duplicate $PATH entries.
	# -------------------------------------------------------------------------
	cleanPath() {
		if [ -n "$PATH" ]; then				# if the system PATH exists
		  oldPath=$PATH:; newPath=			# make a copy & new working space
		  while [ -n "$oldPath" ]; do		# while there's still something left
			x=${oldPath%%:*}				# get the first remaining entry
			case $newPath: in
			  *:"$x":*) ;;					# already there, do nothing
			  *) newPath=$newPath:$x;;    	# not there yet; add
			esac
			oldPath=${oldPath#*:}
		  done
		  PATH=${newPath#:}					# set system PATH to uniq'd version
		  unset oldPath newPath x			# clean up after ourselves
		fi
	}
	cleanPath								# remove duplicates from PATH
	export PATH								# share and enjoy!

	# -------------------------------------------------------------------------
	# THIS MUST BE AT THE END OF THE FILE BECAUSE rvm IS FRAGILE AND WILL YELL
	# ABOUT "is not at first place". GRRRR
	# -------------------------------------------------------------------------
	# rvm (Ruby version manager)
	# -------------------------------------------------------------------------
	# Load RVM into a shell session _as a function_
	# shellcheck source=/Users/michael.sattler/.rvm/scripts/rvm
#	[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"

	export rvm_bash_nounset=${rvm_bash_nounset:-} # initialize if unbound variable
	export rvm_error_clr=${rvm_error_clr:-}	# initialize if unbound variable
	export _system_name=${_system_name:-}	# initialize if unbound variable
	export __rvm_sed=${__rvm_sed:-}			# initialize if unbound variable
fi
